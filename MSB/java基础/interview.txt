HashTable、HashMap、ConcurrentHashMap
1、集合
（1）非安全集合：list、set、map
（2）普通安全集合：vector、HashTable
（3）高性能的安全集合：map（ConcurrentHashMap）、set（ConcurrentSkipListSet）、queue（array、linked）、copyonwrietArrayList

2、ConcurrentHashMap原理？
https://www.jianshu.com/p/4e03b08dc007
（1）jdk1.7
结构：Segment分段锁+数组。将数据分成一段一段存储，然后每一段分配一把锁，每段的结构就是HashTable。
锁：每一段分配一把锁，当一个线程占用锁访问其他一段数据的时候，其他段的数据也能被其他线程访问。
查找数据：两次Hash，先段、再数组(key.hashCode)

（2）jdk1.8
结构：数组+链表+红黑树，当链表长度超过8的时候，将链表转换为红黑树
锁：取消分段锁，采用CAS与sync保证并发安全，锁的是当前链表或者红黑数的首节点，只要hash不冲突，就不会产生并发

3、如何在很短的时间内将大量数据插入到ConcurrentHashMap，换句话说，就是提高ConcurrentHashMap的插入效率？
主要涉及到扩容、hash冲突时锁的竞争
（1）第一个扩容的问题，主要还是要通过配置合理的容量大小和扩容因子，尽可能减少扩容事件的发生
（2）第二个锁资源的争夺，在put方法中会使用synchonized对头节点进行加锁，而锁本身也是分等级的，因此我们的主要思路就是尽可能的避免锁等级。
所以，针对第二点，我们可以将数据通过通过ConcurrentHashMap的spread方法进行预处理，这样我们可以将存在hash冲突的数据放在一个组里面，每个组都使用单线程进行put操作，这样的话可以保证锁仅停留在偏向锁这个级别，不会升级，从而提升效率。

3、HashMap
（1）结构：数组+链表+红黑树
（2）变量
        Entry：Node<K,V>
        table：存储Node的数组
        size：HashMap数据个数
        capacity：HashMap容量
        loadFactor：负载因子，用于计算扩容的阈值threshold（loadFactor*capacity）

（3）Hash
       a）Hash算法
      	 将hash值高位（前16位）参与到取模的运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率

       b）解决Hash冲突
	竖向：开放地址法（不断往下找空闲位置）
	横向：链地址法
	再hash
   	

（4）为什么扩容？
由于桶的数量不够，导致频繁产生Hash冲突，使得HashMap性能下降；
因此通过扩容缓解Hash冲突。

（5）何时扩容？
当添加数据之后，发现size大于threshold的时候会调用resize进行扩容

（6）扩容过程
假设扩容前的table大小为2的N次方，有上述put方法解析可知，元素的table索引为其hash值的后N位确定
扩容后的table大小即为2的N+1次方，则其中元素的table索引为其hash值的后N+1位确定，比原来多了一位

元素hash值第N+1位为0：不需要进行位置调整（hash值与大小为2^n一样，因此不需要调整）
元素hash值第N+1位为1：调整至原索引的两倍位置

4、HashTable
结构：数组+链表
锁：整张HashTable


5、jdk1.8的新特性？
a、接口：
（1）默认方法：允许接口有一个非抽象的方法，但是需要加default修饰
（2）函数式接口（用于支持lambda表达式）：有且仅有一个抽象方法（排除default修饰的方法、覆盖Object的方法）

b、lambda：
（1）lambda表达式（匿名内部类【实现函数式接口】的简写）：
        对象：必须是函数式接口 的匿名内部类
        结构：（参数名列表）->{一些重要方法的代码};

（2）方法引用（若lambda体中的内容，有方法已经实现了，则可以使用方法引用）Runnable接口就可以使用方法引用
     三种格式：
	对象::实例方法名
	类::静态方法名
	类::实例方法名

c、Stream：（流是数据渠道，用于操作数据源（集合、数组等）生成的元素序列）
  操作步骤：
  1）获取流：stream串行流、parallelStream并行流【forkJoinPool，把大任务分为多个子任务，通过不同线程分别处理每个任务，最终再合并起来】
  2）中间操作：对数据源进行操作
  3）终止操作：执行中间操作链并产生结果


6、面向对象的特性？
（1）封装
意义：隐藏对象的属性和实现细节，对外公开使用方式；防止被修改
原则：高内聚、低耦合

（2）继承
意义：重用代码，节省开发时间
注意点：非静态属性和方法可以被继承和重写。但是静态属性和方法可以被继承，但是没有被重写(overwrite)而是被隐藏，即调用的都是父类的属性和方法。

（3）多态
意义：处理参数，不同对象处理参数的方式不一样
条件：继承或者实现接口、重写方法、父类引用指向子类对象


7、ForkJoinPool
（1）出现的原因：处理器核心数发展到很多，如果按照任务为单位进行并发处理，并不能很好利用CPU资源，因为一般应用并没有那么多任务处理。基于这种现状考虑，将大任务拆分成多个子任务，每个子任务都能得到执行，最后合并结果。
（2）ForkJoinPool：fork子任务、join合并结果。

8、ForkJoinPool之常用线程池WorkStealPool
每个线程对应一个任务队列。
如果某个线程处理比较快，会从其他线程的任务队列中取任务执行，此时就可能涉及到线程并发问题。


9、jdk动态代理
（1）被代理类、以及实现的接口
（2）声明代理方法：实现InvocationHandler接口
（3）Proxy.newProxyInstance（InvocationHandler）

10、cglib动态代理
（1）被代理类
（2）通过enhancer设置被代理类、设置MethodIntercept
（3）enhance.create()

11、tomcat为什么要自定义类加载器？
Tomcat 拥有不同的自定义类加载器，以实现对各种资源库的控制。
（1）同一个Tomcat中(在同一个JVM)，各个Web应用使用的Java类库要隔离。设想一下，两个Web应用，一个使用了Spring2.5，另一个使用了教新的4.0，应用服务器使用一个类加载器，Web应用将会因为jar包覆盖而无法启动。
（2）同一个Tomcat中，各个Web应用之间可以提供共享的Java类库。
（3）为了使Tomcat不受Web应用的影响，应该使服务器的类库与应用程序的类库互相独立。
（4）Tomcat支持热部署：jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，没有自定义类加载器的话，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。


12、反射
（1）含义
运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。

（2）作用
解耦，降低组件之间的耦合度
动态代理

（3）优化反射
缓存Method（Redis），不重复调用getMethod


13、HashMap为什么要采用红黑树而不是AVL树？
（1）AVL树：严格的平衡二叉树，左右子树的高不能超过1，否则需要旋转平衡。增加和删除很有可能需要一次或者多次旋转来平衡。旋转频率比较高。
（2）红黑树：弱平衡二叉树，根节点到叶子节点的最长路径不会超过最短路径的两倍。
	      相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，用红黑树


14、工厂模式
工厂：任何能够产生对象的方法或者类

（1）简单工厂（静态工厂模式）：一个工厂，生产多个产品
含义：可以传入不同的字符串来调用工厂类的静态方法创建不同具体产品类的实例
缺点：违反开闭原则，新增产品的时候，需要修改工厂类

（2）工厂方法：多个工厂，每个工厂生产一种产品
含义：将工厂类抽象出一个基类，根据不同的产品，创建不同的工厂类。
优点：新增产品，无需修改原来代码；只需要新增一个工厂类及对应的生产方法

（3）抽象工厂：多个工厂，每个工厂生产多种产品
含义：提供一个创建产品族（一系列相关或相互依赖对象）的接口，无须指定它们具体的类。
优点：抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。


14、创建型设计模式：对象实例化的模式o
（1）原型：通过拷贝原型创建新的对象。clone
（2）工厂模式：简单工厂、工厂方法、抽象工厂
（3）单例模式：懒汉式、饿汉式、静态内部类

15、结构型设计模式：将类或者对象组合成一个更大的结构
（1）门面模式：对外提供一个统一的接口，用于访问子系统内部的一群接口。
优点：解耦（客户端与子系统解耦）、简单易用
例子：doPost、doGet

（2）装饰者模式：动态地添加、撤销对象的功能的设计模式。相比于使用继承，装饰者模式更加灵活。
结构：被装饰者（实现同一个接口）+装饰者（初始化的时候设置被装饰者，继承被装饰者；这样在装饰的时候利用多态的特性，添加不同的功能）

（3）代理模式
静态代理：代理类和被代理类都实现了相同的接口，相对于在被代理类的基础之上封装了一层，会出现大量代码重复
jdk动态代理：面向接口代理，可以在不修改原有代码的基础上，动态增强对象功能
cglib动态代理：面向类代理

16、行为型设计模式：用于描述类或对象之间怎样相互协作共同完成任务
（1）责任链模式
结构：拦截链（包含拦截器）、拦截器（实现同一个接口）
例子：过滤器Filter

（2）观察者模式
结构：观察者（注册到被观察者里面）、被观察者（通知事件给观察者）

（3）模板方法：
父类定义好方法模板，但是方法得子类实现
类加载loadClass的findClass


17、序列化与反序列化
序列化：将对象转换为字节，以待后续在相同或另一台计算机环境中，能恢复原先状态的过程

反序列化：将字节转换为对象


18、在 Java 中定义一个不做事且没有参数的构造方法的作用 ？
方便子类继承
子类构造方法中，往往默认使用super调用父类的无参构造方法，但是父类在如果没有定义无参构造就会报错，需要子类调用super的时候传递参数。

19、String、StringBuilder、StringBuffer之间的区别
（1）可变性
String底层是final static char[]，不可变的
StringBuilder、StringBuffer：都继承自AbstractStringBuilder，底层是char[]，是可变的

（2）线程安全
String：常量，可以认为是线程安全的
StringBuilder：非线程安全
StringBuffer：方法都在同步锁，线程安全

（3）使用场景
String：操作少量数据
StringBuilder：单线程处理大量数据
StringBuffer：多线程处理大量数据

20、Exception（运行时异常、受检异常）、Error有何异同？
在 Java 中 Throwable 是程序错误处理的父类，它有两个子类：Error 和 Exception。
（1）Error：属于 JVM 层次的严重错误，导致 JVM 无法继续执行，因此，这是不可捕捉的，无法采取任何恢复的操作，顶多只能显示错误信息。
（2）受检异常：IO异常、SQL异常，编译器会强制我们写try、catch
（3）运行时异常：空指针异常、数组越界等等。我们可以不处理。当出现异常的时候，JVM会把异常一直往上层抛，直到遇到处理代码，如果主程序抛出异常，程序退出。


21、instance与inInstance
a instance A：对象a是不是这种类型A
A.class.inInstance(a)：对象a能不能转换为类型A

22、泛型
（1）含义
类型参数化。
定义类、接口、方法的时候，使用类型作为参数，<T>如果未指定类型默认是Object类型；<T extends x><T  super y>如果指定类型，就是某个类型。
使用的时候，直到具体类型。

（2）为什么使用泛型
编译时确定类型，保证类型安全，避免类型转换异常。
代码重用性好。

（3）泛型的使用
泛型类：public class Demo<T> {} ，T表示未知类型。
泛型接口：public interface ImplDemo<T,V>{} ，和定义类一样(接口就是一个特殊类)。
泛型方法：public <T> void demo1(T name){System.out.println(name);} , public <T> T demo2(T t){ return t;}

（4）类型擦除
类型是在编译时候就确定的。
类型擦除就是Java 编译器擦除所有类型参数，如果类型参数有界，则用它的第一个边界替换每个参数，如果没有边界则用 Object 替换。
举例：List<Integer> List<String>