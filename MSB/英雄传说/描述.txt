1、描述
基于英雄作战的题材，单服架构。

2、技术
Netty（接收客户端IO请求）+ 本地缓存 + Redis（缓存用户数据、排行榜）+Mysql（用户信息）+MQ+反射（解耦）
服务器主要是进行处理、存储用户消息

3、开发前的准备
（1）明确会有哪些消息
根据业务需求，生成消息文档（按照ProBuf文档格式）：用户角色信息、用户移动信息、用户攻击信息、用户死亡信息、用户退出信息等等；
使用Probuf命令行，将消息文档生成对应的代码：包含消息、解码器

（2）对象预埋：对于无状态的对象，可以在服务器启动的时候就生成
a）消息解码器
     原因：因为通过Netty接收到的数据是二进制流，需要对其进行解码，考虑到解码器是无状态的，所以可以在服务器启动的时候就生成；
     手段：通过反射生成，主要是通过遍历所有的解码器，然后调用newInstance生成对象，然后放在HashMap中

b）消息处理器
    原因：对于不同的消息类型，我们需要进行不同的处理
    手段：将所有的消息处理器类放在handler包下，然后遍历handler包下所有处理器，通过反射newInstance生成对象，放在HashMap中

4、架构、流程
（1）解码：首先，Netty接收到客户端消息，取出消息头，根据消息头获取对应的消息解析器，对消息进行解码
（2）获取handler：获取到消息之后，通过一个异步业务主线程进行处理（不占用Netty的IO线程，保证Netty的高吞吐量），主线程会根据消息获取消息处理器，然后进行消息处理
（3）处理逻辑：在handler处理逻辑里面，对于逻辑简单的直接就在主线程里面处理；而如果设计到复杂操作、数据库操作，由于涉及到IO处理，会通过异步线程池进行处理
（4）举例
        Redis缓存失效，如何解决？
        并发更新数据库，如何保证一致性？
        Mysql与Redis如何保持一致性？

（5）扩展功能点：排行榜功能【不重启服务器的情况下，动态的修改排行榜功能】
a）主线程将用户攻击次数写到MQ中
b）会有消费者进程（与服务器无关）定时从MQ中取数据，然后它会将数据存储到另外一台Redis服务器中，主要是利用Redis的Zset实现排行榜功能
c）这样服务器就能从Redis中获取出排行榜信息，返回给客户端
                   
