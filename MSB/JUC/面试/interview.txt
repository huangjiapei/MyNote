1、wait与sleep区别与联系？
（1）区别
所属类：
sleep针对的是线程， 所以不可能是对象的方法，所以它理应在Thread类里面，当作一个方法。
wait在sync锁里面，所以与锁相关、与对象头相关，所以它理应属于对象，所以在Object的方法中。

锁：
sleep是针对线程本身，所以不涉及到对象锁相关的东西。
wait与锁相关，它会释放锁。


（2）联系
两者都会导致线程阻塞；
两者均可被中断处理。


2、进程与线程
进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位，包括：数据段、代码段、堆、栈空间。

线程：线程——程序执行的最小单位。系统 分配 处理器时间资源 的基本单元。


3、什么是IO密集型和CPU密集型？
（1）CPU密集型：加密、解密、压缩、各种算法，占用CPU。
（2）IO密集型：文件操作，在文件读取的时间段不占用CPU，此时就需要利用这个间隔时间，用于运行其他线程

3、程序开多少线程合理？
（1）首先，开多少线程是和业务紧密相关的。
（2）需要分为IO密集型和CPU密集型。
（3）如果是CPU密集型(加密、解密、压缩、各种算法，占用CPU)，需要减少上下文的切换时间，如果一个CPU对应一个线程，那么此时它就不需要切换，此时线程数与CPU核数一样即可。
（4）如果是IO密集型（文件操作，读取文件得时候不占用CPU），就需要估算IO停顿的时间，假如IO停顿时间是1、2s（需要充分利用这个停顿时间），就可以开无限多个线程，因为对于ns级别的CPU来说1、2s已经有足够时间去处理其他线程，此时就需要考虑线程资源和业务量，假如资源无限大，IO密集型就可以开无限多个线程；
如果既要节约资源又要保证高性能，最好的方案是线程数为CPU核数的两倍，通过压测可以适当增加线程数。
比如Netty是IO密集型的，它的EventLoop除了完成IO操作，还有自己的逻辑，大约75%时间在做IO操作，其他时间做自己的时间。


4、sync与lock区别？
总：
（1）由于以前sync还没有优化的时候性能很差，所以引入了ReententLock。
（2）sync只有wait和notify功能单一；ReententLock。有condition比较灵活，可以实现一个锁可以有多个等待队列。
分：
......

5、并发与并行有什么区别？
并发：就是把时间切割为一段一段，线程a执行一段时间，然后切换成线程b执行一段时间；如果时间分割得很短，就感觉不出来切换，称为伪并行。如果并发应用在计算机系统中，就会造成应用在不停的切换，只是时间太短，我们感觉不出来。
并行：线程同时运行。

6、并发与并行有什么影响？
多个线程同时争抢一个资源，死锁。

7、如何解决并发和并行的影响？
解决思想：同一时间，只能有一个线程争抢资源，即线程互斥。
解决手段：管程，一个管理程序，每次需要获取资源必须通过管程处理，解决排队操作、唤醒操作。ReetentLock就是管程。
而因为管程可能多个线程同时访问，它的原子性操作是由信号量P（++）V（--）保证的。（中断：会造成线程切换）
（保证原子性：关中断，不进行线程切换；或者lock锁总线 lock incr, lock desc）

8、ABA是什么？
总：对于某个东西，拿过来做了某些操作，然后又还回去了，导致其他人不知道这个东西已经发生过变化，因为它还是原来的样子。
分：对于一个变量A，线程1将其修改为B，更新完成之后，线程2又将变量B修改为A；最后线程3看到变量值预期的A，它并不知道又A->B->A得过程，这就是ABA问题。


解决方法：加版本号


9、volatile与DCL？
禁止指令重排序。
创建对象过程：
（1）为对象分配空间
（2）执行对象得init方法
（3）返回对象得引用

10、DCL
syn有两个队列，一个是等待队列（等待池），一个是竞争队列（锁池）.
有可能两个线程同时进入第一个if语句，导致这两个线程在等待队列里面，当锁释放得时候，会把线程从等待队列移竞争队列中，如果不加第二个if判断得话会导致两个对象同时触发。


11、阻塞队列得实现
ArrayBlockingQueue（一把锁）、LinkedBlockingQueue（两把锁）
（1）变量
Lock：一把资源锁
Condition：两个条件等待队列，生产者、消费者

（2）生产者代码
（3）消费者代码

12、交替输出？
输出得顺序：value控制
等待与唤醒：a唤醒b、b唤醒c、c唤醒a


13、任务结束会不会回收线程？
首先，需要看是核心线程还是非核心线程。
对于非核心线程，等待一段时间后没有拿到任务，他就会超时回收。
对于核心线程，等待一段时间后没有拿到任务，如果指定允许核心线程睡眠，则核心线程会进行睡眠。

14、ThreadLocl原理？
（1）Thread有个ThreadLocalMap变量，实际是Map结构
（2）调用ThreadLocal.set
（3）调用ThreadLocal.get

key内存泄漏
value内存泄漏


15、缓存与数据库一致性
先写数据库，在改缓存，然后再通过定时任务校准缓存和数据库的一致性，根据业务的时效性决定定时时间。