【指令：watch、pipeline、exec】
【场景：分布式锁、缓存、数据类型】
【问题】
【持久化】
【主从（同步机制）、集群】

1、Redis的乐观锁？
【watch 命令会监视给定的每一个key，当exec时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。
（1）乐观锁
watch指令在redis事物中提供了CAS的行为。为了检测被watch的keys在是否有多个clients同时改变引起冲突，这些keys将会被监控。
如果至少有一个被监控的key在执行exec命令前被修改，整个事物将会回滚，不执行任何动作，从而保证原子性操作，并且执行exec会得到null的回复。

（2）乐观锁工作机制
watch 命令会监视给定的每一个key，当exec时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。
注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。
当然exec，discard，unwatch命令，及客户端连接关闭都会清除连接中的所有监视。
还有，如果watch一个不稳定(有生命周期)的key并且此key自然过期，exec仍然会执行事务队列的指令。

1、Redis是什么？
磁盘存储缺点->引出Redis出现的原因
（1）是什么：redis是一个高性能的key-value数据库，是一个非关系型的数据库，整个数据库是加载在内存中。IO多线程、工程线程单线程。
（2）性能：纯内存操作，每秒可以处理10w此读写操作。
（3）数据结构：有丰富数据类型，单个value最大限制1G，并且还有对应的方法
（4）缺点：数据库容量受到物理内存限制，不适合做海量数据的高性能读写


2、Redis基本数据类型？
       String：点赞、秒杀
       List：粉丝列表、消息队列
       Set：共同好友
       Hash：用户信息
       Zset：排行榜

3、Redis应用场景
（1）缓存
（2）基本数据类型
（3）分布式锁

3、Redis应用场景->分布式锁
问题：
（1）抢占到锁：程序挂掉，未释放
（2）未抢占到锁：客户端不断发送请求，使得IO吞吐量上升
（3）设置过期时间：线程抢占到锁，并设置过期时间，可能出现时间到了，锁失效了，其他线程拿到锁，出现锁不一致。

如何实现：
（1）Redis锁，设置过期时间，监控线程

（2）红锁：客户端实现，多台Redis，抢到一个Redis计数加1，过半则认为加锁成功


4、Redis应用场景->缓存
（1）含义
存储的不是全量数据，而是热点数据，并且会实时变化。
为了减轻后端的访问压力。

（2）生存时间命令
        a）查看生存时间：TTL
        b）更新生存时间：Expire

（3）key过期，何时删除地址空间
        a）被动删除：如果用户不去访问过期key，那么它就不会从内存中清除
        b）主动删除：基于概率算法，Redis每秒做10次如下的步骤：
	随机测试100个设置了过期时间的key
	删除已过期的key
	若删除的key超过25个则重复步骤1
        c）当发现已用内存超过maxmemory的时候，触发主动清理策略：LRU、Random、TTL即将过期的


5、Redis持久化（RDB、AOF）
（1）RDB
         a）含义：快照，将数据序列化全部拷贝到磁盘；恢复速度快
         b）实现方式
	*save：阻塞，Redis在写快照到磁盘的时候，不对外提供服务，只写快照。
	*bgsave：fork+copyOnWrite，fork出子进程，子进程负责写快照，父进程负责增删改，父进程修改的时候会触发copy，子进程看不到。
		优点是fork创建子进程速度快，且不会占用太多内存。
         c）缺点
	不支持拉链，数据易失

（2）AOF
         a）含义：写操作记录到磁盘中，会追加（Redis4.0将老数据以RDB的形式存储到AOF文件中，新增的指令Append到AOF文件后面）；恢复慢
         b）何时触发：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf缓冲区的末尾
         c）实现方式
	*手动命令：bgrewriteaof
	*自动修改配置文件：auto-aof-rewrite-percentage 100/auto-aof-rewrite-min-size 64mb
	（何时刷新磁盘：always【无论内核buffer有没有满，都写到磁盘】；no【内核buffer满了，才写到磁盘】；seconds【每秒flush到磁盘】）

6、Redis主从复制
（1）强一致性、弱一致性、最终一致性

7、Redis集群
（1）一致性Hash（服务器只能对应一个value：一对一）
         含义：Hash空间为一个虚拟的圆环，从0~2^32-1，对2^32取模（可能出现数据倾斜，会对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。）
         i）服务器确定位置：对每个服务器使用Hash计算hash值，确定在哈希环的一个位置
         ii）数据定位到服务器：将Key进行Hash计算，计算出数据在环上位置，从此位置按照顺时针查找，遇到的服务器就是定位到的服务器。
（2）一致性Hash，容错性
         某台服务器宕机了或者新增服务器，也只会影响一台服务器

（3）哈希槽位->Redis集群采用的方式（服务器可以对应多个value：一对多）
a）流程：
         i）预分区：Redis有16384个哈希槽，给每个服务器都分配一些槽位称为mapping（从服务器不分配槽位）
         ii）数据定位到服务器：通过key计算槽位，如果在当前Redis则直接返回；复制重定向到对应的Redis进行获取

b）Redis如何通过哈希槽实现数据共享：
         如果我想添加一个新节点D，我需要将节点A，B，C中的一些散列槽移动到D。
         同样，如果我想从集群中删除节点A，我可以只移动由A使用的散列槽到B和C	

c）与一致性Hash对比
        i）哈希槽是通过槽位定位服务器；一致性hash是通过key-value定位数据

8、Redis问题
（1）击穿：存在的数据失效
        https://blog.csdn.net/zyjzyj2/article/details/105027746
        a）主动刷新缓存：定时任务查询数据库，保存到Redis中
	优点：请求压力永远不会打到数据看中，查询效率高
	缺点：对Redis内存消耗大；增加系统复杂度
	场景：查询的数据变化不大；优化请求量很大的情况

        b）分布式锁+双重检查
	缺点：每次只能有一个线程访问数据库，会阻塞其他线程【DCL】

        c）普通jvm锁查询缓存，数据库压力不至于只能支撑一个线程访问，可以每个jvm可以去访问数据库，如果有s台服务器，那么同一时间可以允许s个请求打到数据库中【DCL】

        d）多级缓存，JVM缓存、Redis缓存，只有在JVM缓存失效、Redis失效的情况下，才去查询数据库
	缺点：浪费服务器内存空间

（2）穿透：不存在的数据
         a）当查询返回空数据的时候，将空数据存储到缓存中，过期时间不宜太长
         b）Bloom过滤器
	作用：向量表+一系列映射函数。检索一个数据是否在一个集合中。
	优点：空间效率和查询时间都比一般算法好。
	缺点：有一定误识别率与删除困难。
	原理：
	          1）全0的向量表
	          2）添加一个关键字，经过多个hash函数，将向量表某些位变为1
	          3）查询关键字，也是经过多个hash函数，对比向量表对应的位是否为1，如果为全为1表示存在

	

（3）雪崩：大量数据失效或者Redis挂掉
         a）大量数据失效解决方案：随机设置一个过期时间
         b）Redis挂掉解决方案：
	事发前：实现高可用（主从+哨兵+集群）
	事发中：本地缓存+限流（击穿的解决方案），避免数据库被干掉
	事发后：Redis持久化，重新从磁盘中加载数据，快速恢复数据

	


9、守护线程与非守护线程区别
任何一个守护线程都会守护整个JVM中所有的非守护线程，只要当前JVM中还有任何一个非守护线程没有结束，守护线程就全部工作，当所有的非守护线程全部结束后，守护线程也会随着JVM一同结束。守护线程最典型的应用就是GC（垃圾回收器）。

作者：逝去丶浅秋
链接：https://www.jianshu.com/p/881e60c386a6
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


10、AOF
（1）含义
         将操作记录存储到AOF文件中
（2）流程（前提：打开AOF功能）
         a）命令传播
              当一个 Redis 客户端需要执行命令时， 将协议文本发送给 Redis 服务器。
              服务器将 Redis 网络通讯协议转换为命令。

         b）缓存追加
	接受命令。
	将命令还原成 Redis 网络通讯协议。
	将协议文本追加到 aof_buf 末尾。

         c）文件写入(写到内核)和保存（保存到磁盘）
	主要有3种方式：Always（每执行一个命令就写到磁盘）、no（内核缓冲区满了才写磁盘）、second（内核缓冲区每秒写磁盘一次）
	
（3）重写
        原因：随着运行时间的流逝， AOF 文件会变得越来越大；通过fork子进程进行命令重写（抵消某些操作）
        流程：
	a）主进程不仅将命令追加到AOF缓冲区，还将命令追加到AOF重写缓冲区
	b）子进程进行命令重写
	c）子进程重写完成，通知主进程；主进程将AOF重写缓冲区中内容全部写到新的AOF文件中，然后覆盖原有AOF文件


11、Redis主从模型->主从同步
（1）弱一致性：异步线程进行同步

（2）全量同步：发生在从初始化阶段，这是从需要从主的所有数据都复制一份
	-  从服务器连接主服务器，发送SYNC命令； 
	-  主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
	-  主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
	-  从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
	-  主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
	-  从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；

（3）增量同步：从初始化完成之后，主服务器把写操作同步到从服务器
	-主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。


12、Redis主从模型->哨兵
（1）为什么有哨兵机制：Redis无法对主进行动态选择，需要使用哨兵监控完成动态选举
（2）作用：
 	a）监控：哨兵会不断检查主从服务器是否正常
	b）提醒：当某个Redis服务器出现问题的时候，哨兵会通过API通知管理员或者其他应用程序
	c）自动故障迁移：当发生故障的时候；会通过投票将其中一个从升级为主。

