1、三色标记
我们把遍历对象图过程中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：

白色：尚未访问过。
灰色：本对象已访问过，而且本对象引用到的其他对象也全部访问过了。
黑色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问完。全部访问后，会转换为黑色。

2、三色标记算法->找出存活对象
1）初始时，所有对象都在【白色集合】中；
2）将 GC Roots 直接引用到的对象挪到 【灰色集合】中；
3）从灰色集合中获取对象：
     3.1） 将本对象引用到的其他对象全部挪到 【灰色集合】中；
     3.2） 将本对象挪到【黑色集合】里面。
4）重复步骤3，直至【灰色集合】为空时结束。
5）结束后，仍在【白色集合】的对象即为 GC Roots 不可达，可以进行回收。

2、三色标记问题
（1）多标（垃圾没被回收）
本应该回收却没有被回收，称为“浮动垃圾”
浮动垃圾不会影响程序的正确性，只能等待下一轮进行回收。

（2）漏标
不是垃圾，却被回收


3、写屏障（不同于JVM的屏障）
在写之前增加某些操作

4、STAB
关注引用的删除，将被删除的引用保存下来
恢复：G1利用RSet查看是否有新引用指向被删除的引用

5、增量更新
关注引用的添加，将黑色重新标记为灰色
恢复：重新遍历灰色对象