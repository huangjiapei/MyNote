1、手段
（1）开启慢查询log（它只告诉了你哪些语句慢，但是为什么慢，需要自己分析，不断的调试）
	set long_query_time=1;//慢查询的时间
	set global slow_query_log='ON'//log文件

         查看log：mysqldumpslow，查询时间、等待锁的时间

（2）explain查看执行情况

2、分析原因
SQL语句：
（1）没有使用索引
（2）查询数据量很大
（3）SQL语句不好，导致额外性能消耗

硬件：
（1）内存不足
（2）IO吞吐量小
（3）网速慢

Mysql：
（1）死锁

     1）没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷) 
          解决方法：explain查看执行计划

     2）I/O吞吐量小，形成了瓶颈效应，磁盘的I/O(即磁盘的读写速度)远远跟不上CPU的处理速度。 
          解决方法：当读写I/O响应速度跟不上时，增加硬盘的个数，扩大存储
	           尽可能的选择一些读写速度高的磁盘来解决问题(ssd)

     3）没有创建计算列导致查询不优化。 

     4）内存不足 
          解决方法：升级硬件；扩大服务器的内存

     5）网络速度慢 
          解决方法：提高网速

     6）查询出的数据量过大
          解决方法：在查询Select语句中用Where字句限制返回的行数,避免表扫描；
                           可以采用多次查询，其他的方法降低数据量

     7）锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷) 
          锁释放：锁的释放是在commit之后
          解决方法：修改程序的逻辑顺序，给出一个合适的程序执行逻辑顺序。避免同时锁定两个资源的现象发生。给SQL语句安排一个先后顺序。
                           按照一定的次序来访问你的表。如果你先锁住表A，再锁住表B，那么在所有的存储过程中都要按照这个顺序来锁定它们。如果你（不经意的）某个存储过程中先锁定表B，再锁定表A，这可能就会导致一个死锁。如果锁定顺序没有被预先详细的设计好，死锁很难被发现 

     8）sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。 
     9）返回了不必要的行和列 
          解决方法：查询时不要返回不需要的行、列 

     10）查询语句不好，没有优化 
          解决方法：
          好的语句：注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。重复的记录在查询里是没有问题的 
	           union all只是合并查询结果，并不会进行去重和排序操作，在没有去重的前提下，使用union all的执行效率要比union高
              	           between在某些时候比IN速度更快,Between能够更快地根据索引找到范围。用查询优化器可见到差别。 
	           没有必要时不要用DISTINCT和ORDER BY，这些动作可以改在客户端执行。