【加锁，写请求串行化】
【先更新数据库，再删除缓存（异步线程）】解决：并发写
【先更新数据库，再删除缓存（cannal订阅binlog，然后写到信息队列，消费者删除缓存）】

https://blog.csdn.net/qq1353424111/article/details/108659708
1、问题
高并发场景下，如何保证缓存与数据库一致性？

********************************************************************************************************************************************************************************************************************************
2、两种流程
（1）写流程
         先删除缓存，再更新数据库，异步回刷缓存
（2）读流程
         先读缓存，缓存没有再读数据库，异步回刷缓存


********************************************************************************************************************************************************************************************************************************
3、两种场景
（1）并发写不一致问题（由于没有加锁导致同时访问）
        假设此时有一个请求A，B都在在执行写流程，请求A是需要将某个数据改成1，请求B是需要将某个数据改为2，执行操作如下时就会导致数据不一致的问题：
        1.请求A执行操作1.1删除缓存。
        2.请求A执行操作1.2更新数据库，将值改为1。
        3.请求B执行操作1.1删除缓存。
        4.请求B执行操作1.2更新数据库，将值改为2
        5.假设说请求B所在服务器网络延迟比较低，请求B先更新缓存，此时缓存中的key对应的value是2。
        6.请求A更新缓存，将缓存中B更新的数据进行覆盖，将key对应的值改为1。

        此时数据库中是B修改后的数据，值为2，而缓存中的数据是1，这样在缓存过期前，用户读到的都是脏数据，与数据库不一致。

（2）并发读写不一致问题【A：1（删除缓存），2（更新数据库、更新缓存）；B：2（读缓存，读数据库），1（更新缓存）】
        假设此时有一个请求A在执行写流程，将原值由1改成2，请求B执行读流程，执行操作如下时就会导致数据不一致的问题：
        1.写请求A执行1.1操作删除缓存key，value是原值1。
        2.读请求B执行2.1操作发现缓存中没有数据，就去执行2.2操作读数据库，读到旧数据，值为1。
        3.写请求A执行1.2操作更新数据库，将数据由1改为2。
        4.写请求A执行1.3操作更新缓存，此时缓存中的数据key对应的value是2。
        5.读请求B执行2.3操作更新缓存，将之前读到的旧数据1设置到缓存中，此时缓存中的数据key对应的value是1。

        所以如果说读请求B所在服务器网络延迟比较高，去执行2.3操作比写请求A晚，就会导致写请求A更新完缓存后，读请求B使用之前读到的旧数据去更新缓存，此时缓存中数据就与数据库中的不一致。


********************************************************************************************************************************************************************************************************************************
4、解决方案
4.1 写请求串行化【只能解决并发写不一致问题】
（1）实现方法
        1）写请求
             1.写请求更新之前先获取分布式锁，获得之后才能去数据库更新这个数据，获取不到就进行等待，超时后就返回更新失败。
             2.更新完之后去刷新缓存，如果刷新失败，放到内存队列中进行重试（重试时取数据库最新数据更新缓存）。
        2）读请求
             读请求发现缓存中没有数据时，直接去读取数据库，读完更新缓存。

（2）总结
        这种技术方案通过对写请求的实现串行化来保证数据一致性，但是会导致吞吐量变低。
        比较适合银行相关的业务，因为对于银行项目来说，保证数据一致性比可用性更加重要。
        就像是去存款机存钱，取钱时，为了保证账户安全，都是会让用户执行操作后，等待一段时间才能获得反馈，这段时间其实取款机是不可用的。



********************************************************************************************************************************************************************************************************************************
4.2 先更新数据库，异步删除缓存，删除失败后重试【写请求先更新数据库，再删除缓存；读请求更新缓存】
（1）实现方法
        1）写请求
             1.先更新数据库
             2.异步删除缓存（如果数据库是读写分离的，那么删除缓存时需要延迟删除，否则可能会在删除缓存时，从库还没有收到更新后的数据，其他读请求就去从库读到旧数据然后设置到缓存中。
             3.删除缓存失败时，将删除的key放到内存队列或者是消息队列中进行异步重试
        2）读请求
             读请求发现缓存中没有数据时，直接去读取数据库，读完更新缓存（还需要判断缓存是否已经存在）。

（2）问题
        在更新完数据库后，我们为什么不直接更新，而是采用删除缓存呢？
       a） 这是因为直接更新缓存的话，在高并发场景下，有多个更新请求时，难以保证后更新数据库的请求会后更新缓存，也就是上面的高并发写问题。
             如果采用删除缓存，可以让下次读时读取数据库，更新缓存，保证一致性。
       b）另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份。
            如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到。
            举个例子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；
            但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。


********************************************************************************************************************************************************************************************************************************
4.3 业务项目更新数据库，其他项目订阅binlog更新【写请求更新数据库，cannal订阅binglog读取binlog删除缓存；读请求更新缓存】
（1）实现方法
        1）写请求
             1.业务项目直接更新数据库。
             2.cannal项目会读取数据库的binlog，然后解析后发消息到kafka。
             3.然后缓存更新项目订阅topic，从kafka接收到更新数据库操作的消息后，更新缓存，更新缓存失败时，新建异步线程去重试或者将操作发到消息队列，后续再进行处理。
        2）读请求
             读请求发现缓存中没有数据时，直接去读取数据库，读完更新缓存（还需要判断缓存是否已经存在）。

（2）问题
         但是这种方案在更新数据库后，缓存中还是旧值，必须等缓存更新项目消费消息后，更新缓存，缓存中才是最新值。所以更新操作完成与更新生效之间会有一定的延迟。