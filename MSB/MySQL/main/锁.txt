1、读
（1）快照读（select）
  含义：读取的是数据的可见版本（可能是过期的数据），不用加锁
  解决方法：MVCC（无锁化）
  隔离级别：RC（每次都生成新的ReadView）、RR（只有在第一次select的时候产生ReadView，会产生幻读）

（2）当前读（lock in share mode、for update 、insert、update、delete）
  含义：读取的是数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录
  解决方法：锁（表锁：无索引；行锁：有索引）
  隔离级别：RC（表锁：无索引；行锁：有索引）、RR（表锁：无索引；间隙锁：有索引，幻读的解决方法）

2、幻读

（1）含义
     可重复读的情形下，一个事务在前后两次查询同一个范围的时候、后一次查询看到了前一次查询未看到的行。
 （如果使用快照读select，查询到的数据是一样的；如果使用当前读select for update，查询到的数据是不一样的）
     指新插入的行被读到。

（2）幻读原因
     行锁只能锁住行、但是新插入记录这个动作、要更新的是记录之间的间隙。

（3）幻读解决方法
    引入了间隙锁(Gap Lock)。
     a）防止间隙内有新数据被插入
     b）防止已存在的数据，更新成间隙内的数据（例如防止numer=3的记录通过update变成number=5）

3、行锁
（1）分类
	a）第一种叫做Record Lock，行记录的锁，实际上指的锁定索引记录。
	     场景：主键索引或者唯一索引；精确匹配

	b）第二种叫做Gap Lock，也就是间隙锁，它用于锁定索引之间的间隙，但是不会包含记录本身。是为了解决幻读的。
     	     间隙锁是可重复读RR隔离级别下特有的，另外还有几种场景也会不使用间隙锁。事务隔离级别设置为不可重复读RC ，这样肯定没有间隙锁了。
   	     场景：非唯一索引

	c）第三种Next-Key Lock实际上就是相当于Record Lock+Gap Lock的组合（左开右闭）。比如索引有10，20，30几个值，那么被锁住的区间可能会是(-∞,10]，(10,20]，(20,30]，(30,+∞)。

（2）间隙锁锁定的区域
	a）根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B）；
 	b）区间加锁，防止间隙内有新数据插入
 	https://www.jianshu.com/p/bf862c37c4c9/

（3）加锁原则
        原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
        原则 2：查找过程中访问到的对象才会加锁。
        优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
        优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

（3）Innodb自动使用间隙锁的条件
	必须在RR级别下
	检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）


lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。
