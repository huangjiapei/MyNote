1、读写分离
读写分离：insert/update/delete语句操作一台服务器，select操作另一个服务器；
在从库读取数据时，没有读到数据，就去主库进行数据读取。

2、读写分离的原因
因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。
但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。
所以读写分离，解决的是，数据库的写入，影响了查询的效率。

在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。
无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。
因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。

3、读写分离的场景
如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用

4、读写分离需要考虑的问题
（1）二次读取
        在从库读取数据时，没有读到数据，就去主库进行数据读取。但是这种操作还是将读的压力返还给主库，如果有恶意的攻击，主库就爆了。

（2）根据业务，将重要的业务数据的读写都放在主库，其他的业务进行读写分离
        类似付钱的这种业务，读写都到主库，避免延迟的问题，但是例如改个头像啊，个人签名这种比较不重要的就读写分离，查询都去从库查。

5、读写分离的实现方式
（1）基于程序代码内部实现
优点：性能好，因为不需要额外的硬件开支
缺点：需要开发人员实现；并且如果一个数据库宕机了，就需要修改配置重启项目

（2）基于主键代理层实现
代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到，后端数据库，有以下代表性的程序。
mysql_proxy、Amoeba

6、springboot实现读写分离
a、编写配置文件，配置两个数据源信息（读数据源、写数据源）
b、编写数据源类：路由数据源（包含主数据源、从数据源）
c、编写 DbContextHolder 类：通过ThreadLocal用来保存每个线程的是使用读库，还是写库【保存】
d、继承AbstractRoutingDataSource 类：重写方法，获取路由的key，即读库还是写库【get key】
d、通过AOP设置路由的key，即读操作设置读数据源、写操作设置写数据源【set key】

6、总结
读写分离理解和实现相对简单，但是只能减少访问的压力，不能分担存储的压力，当数据增多是，查询的速度还是会很慢。这时候就需要用到分库分表了。
正常情况下，单机不能支撑业务时，才会用数据库集群，软件设计越简单的设计越好。
一般数据库的优化是，先优化一些查询操作，然后优化业务的逻辑，或者加入缓存，最后不行再用集群，最后再分库分表。

（单机->集群->分库分表）
